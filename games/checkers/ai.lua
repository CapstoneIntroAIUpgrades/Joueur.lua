-- Generated by Creer at 02:31PM on October 26, 2015 UTC, git hash: '98604e3773d1933864742cb78acbf6ea0b4ecd7b'
-- This is where you build your AI for the Checkers game.

local class = require("joueur.utilities.class")
local BaseAI = require("joueur.baseAI")

-- <<-- Creer-Merge: requires -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
-- you can add addtional require(s) here
-- <<-- /Creer-Merge: requires -->>

--- @class AI: the AI functions for the Checkers game.
local AI = class(BaseAI)

-- this is the name you send to the server to play as.
function AI:getName()
    -- <<-- Creer-Merge: get-name -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
    return "Checkers Lua Player" -- REPLACE THIS WITH YOUR TEAM NAME!
    -- <<-- /Creer-Merge: get-name -->>
end

-- this is called once the game starts and your AI knows its playerID and game. You can initialize your AI here.
function AI:start()
    -- <<-- Creer-Merge: start -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
    self.checkersMap = Table()
    for x = 0, self.game.boardWidth - 1 do
        self.checkersMap[x] = Table()
    end
    -- <<-- /Creer-Merge: start -->>
end

-- this is called when the game's state updates, so if you are tracking anything you can update it here.
function AI:gameUpdated()
    -- <<-- Creer-Merge: game-updated -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
    for x = 0, self.game.boardWidth - 1 do
        self.checkersMap[x]:empty()
    end

    for i, checker in ipairs(self.game.checkers) do
        self.checkersMap[checker.x][checker.y] = checker
    end
    -- <<-- /Creer-Merge: game-updated -->>
end

--- this is called when the game ends, you can clean up your data and dump files here if need be
-- @param {boolean} won == true means you won, won == false means you lost
-- @param {string} reason you won or lost
function AI:ended(won, reason)
    -- <<-- Creer-Merge: ended -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
    -- replace with your ended
    -- <<-- /Creer-Merge: ended -->>
end

--- Game Logic Functions: functions you must fill out to send data to the game server to actually play the game! ---

--- This is called every time the AI is asked to respond with a command during their turn
-- @returns {boolean} represents if you want to end your turn. true means end the turn, false means to keep your turn going and re-call runTurn()
function AI:runTurn()
    -- <<-- Creer-Merge: runTurn -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
    local checker, x, y = true, 0, 0
    while checker do
        checker, x, y = self:findCheckerToMove()

        if checker then
            checker = checker:move(x, y)
        end
    end

    return true -- if we got here there's nothing to do... so end the turn
    -- <<-- /Creer-Merge: runTurn -->>
end

-- <<-- Creer-Merge: functions -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
function AI:findCheckerToMove()
    local myCheckers = self.player.checkers:copy()
    local forcedJump = false

    if self.game.checkerMoved then -- I have to move that checker
        if self.game.checkerMovedJumped then
            forcedJump = true
            myCheckers = Table( self.game.checkerMoved )
        else
            return
        end
    end

    myCheckers:shuffle()

    local yDirection = self.player.yDirection

    for i, checker in ipairs(myCheckers) do
        local neighbors = Table(
            {x = checker.x + 1, y = checker.y + yDirection},
            {x = checker.x - 1, y = checker.y + yDirection}
        )

        if checker.kinged then -- add neighbors in the opposite direction to investigate
            neighbors:insert({x = checker.x + 1, y = checker.y - yDirection})
            neighbors:insert({x = checker.x - 1, y = checker.y - yDirection})
        end

        neighbors:shuffle()

        while #neighbors > 0 do
            local neighbor = neighbors:pop()

            if neighbor.x >= self.game.boardWidth or neighbor.x < 0 or neighbor.y >= self.game.boardHeight or neighbor.y < 0 then
                -- continue
            else
                if forcedJump then
                    if neighbor.jump then
                        return checker, neighbor.x, neighbor.y
                    end
                else
                    local jumpingChecker = self.checkersMap[neighbor.x][neighbor.y]
                    if jumpingChecker then
                        if jumpingChecker.owner ~= self.player and not neighbor.jump then -- we can try to jump it, so add the neighbor over
                            neighbors:insert({
                                jump = true,
                                x = neighbor.x + (neighbor.x - checker.x),
                                y = neighbor.y + (neighbor.y - checker.y),
                            })
                        end
                    else -- there is no checker there to jump, and it's valid to move there, so move there
                        return checker, neighbor.x, neighbor.y
                    end
                end
            end
        end
    end
end
-- <<-- /Creer-Merge: functions -->>

return AI
