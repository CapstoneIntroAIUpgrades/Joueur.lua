-- Generated by Creer at 03:55PM on April 26, 2015 UTC, git hash: '2acbba9c4b682c4de68840c1ca9bec631e9c635f'
-- This is where you build your AI for the Checkers game.
local class = require("utilities.class")
local BaseAI = require("baseAI")

--- @class AI: the AI functions for the Checkers game.
local AI = class(BaseAI)

-- this is the name you send to the server to play as.
function AI:getName()
    return "Checkers Lua Player"
end

-- this is called once the game starts and your AI knows its playerID and game. You can initialize your AI here.
function AI:start()
    self.checkersMap = Table()
    for x = 0, self.game.boardWidth - 1 do
        self.checkersMap[x] = Table()
    end
end

-- this is called when the game's state updates, so if you are tracking anything you can update it here.
function AI:gameUpdated()
    for x = 0, self.game.boardWidth - 1 do
        self.checkersMap[x]:empty()
    end

    for i, checker in ipairs(self.game.checkers) do
        self.checkersMap[checker.x][checker.y] = checker
    end
end

--- this is called when the game ends, you can clean up your data and dump files here if need be
-- @param {boolean} won == true means you won, won == false means you lost
-- @param {string} reason you won or lost
function AI:ended(won, reason)
    -- pass
end

--- Response Functions: functions you must fill out to send data to the game server to actually play the game! ---

--- This is called every time the AI is asked to respond with a command during their turn
-- @returns <Command> the Command you want to run on the server this turn from a game object's command functions. If you do not return your player's endTurn() then this runTurn function will be called again after the game state updates.
function AI:runTurn()
    local myCheckers = table.copy(self.player.checkers)
    local forcedJump = false

    if self.game.checkerMoved then -- I have to move that checker
        if self.game.checkerMovedJumped then
            forcedJump = true
            myCheckers = { self.game.checkerMoved }
        else
            return self.player:endTurn()
        end
    end

    table.shuffle(myCheckers)

    local yDirection = self.player.yDirection

    for i, checker in ipairs(myCheckers) do
        local neighbors = Table(
            {x = checker.x + 1, y = checker.y + yDirection},
            {x = checker.x - 1, y = checker.y + yDirection}
        )

        if checker.kinged then -- add neighbors in the opposite direction to investigate
            neighbors:insert({x = checker.x + 1, y = checker.y - yDirection})
            neighbors:insert({x = checker.x - 1, y = checker.y - yDirection})
        end

        table.shuffle(neighbors)

        while #neighbors > 0 do
            local neighbor = neighbors:pop()

            if neighbor.x >= self.game.boardWidth or neighbor.x < 0 or neighbor.y >= self.game.boardHeight or neighbor.y < 0 then
                -- continue
            else
                if forcedJump then
                    if neighbor.jump then
                        return checker.move(neighbor.x, neighbor.y)
                    end
                else
                    local jumpingChecker = self.checkersMap[neighbor.x][neighbor.y]
                    if jumpingChecker then
                        if jumpingChecker.owner ~= self.player and not neighbor.jump then -- we can try to jump it, so add the neighbor over
                            neighbors:insert({
                                jump = true,
                                x = neighbor.x + (neighbor.x - checker.x),
                                y = neighbor.y + (neighbor.y - checker.y),
                            })
                        end
                    else -- there is no checker there to jump, and it's valid to move there, so move there
                        return checker:move(neighbor.x, neighbor.y)
                    end
                end
            end
        end
    end

    -- if we got here there's nothing to do...
    return self.player:endTurn()
end

return AI
