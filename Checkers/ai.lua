-- Generated by Creer, git hash c6767247662bdc8024518de1aebc87bcf634ca49
-- This is where you build your AI for the Checkers game.
local class = require("utilities.class")
local BaseAI = require("baseAI")

--- @class AI: the AI functions for the Checkers game.
local AI = class(BaseAI)

-- this is the name you send to the server to play as.
function AI:getName()
    return "Checkers Lua Player"
end

-- this is called once the game starts and your AI knows its playerID and game. You can initialize your AI here.
function AI:gameInitialized()
    self.checkersMap = Table()
    for x = 0, self.game.boardWidth - 1 do
        self.checkersMap[x] = Table()
    end
end

-- this is called when the game's state updates, so if you are tracking anything you can update it here.
function AI:gameUpdated()
    for x = 0, self.game.boardWidth - 1 do
        self.checkersMap[x]:empty()
    end

    for i, checker in ipairs(self.game.checkers) do
        self.checkersMap[checker.x][checker.y] = checker
    end
end

-- this is called every time the server tells you that you can send a command. Once you send a command you must return because the game state will change. This is where most of your game logic will probably go
function AI:run()
    local myCheckers = self.player.checkers:copy()
    local forcedJump = false

    if self.game.checkerMoved then -- I have to move that checker
        if self.game.checkerMovedJumped then
            forcedJump = true
            myCheckers = { self.game.checkerMoved }
        else
            return self.player:endTurn()
        end
    end

    table.shuffle(myCheckers)

    local yDirection = self.player.yDirection

    for i, checker in ipairs(myCheckers) do
        local neighbors = Table(
            {x = checker.x + 1, y = checker.y + yDirection},
            {x = checker.x - 1, y = checker.y + yDirection}
        )

        if checker.kinged then -- add neighbors in the opposite direction to investigate
            neighbors:insert({x = checker.x + 1, y = checker.y - yDirection})
            neighbors:insert({x = checker.x - 1, y = checker.y - yDirection})
        end

        table.shuffle(neighbors)

        while #neighbors > 0 do
            local neighbor = neighbors:pop()

            if neighbor.x >= self.game.boardWidth or neighbor.x < 0 or neighbor.y >= self.game.boardHeight or neighbor.y < 0 then
                -- continue
            else
                if forcedJump then
                    if neighbor.jump then
                        return checker.move(neighbor.x, neighbor.y)
                    end
                else
                    local jumpingChecker = self.checkersMap[neighbor.x][neighbor.y]
                    if jumpingChecker then
                        if jumpingChecker.owner ~= self.player and not neighbor.jump then -- we can try to jump it, so add the neighbor over
                            neighbors:insert({
                                jump = true,
                                x = neighbor.x + (neighbor.x - checker.x),
                                y = neighbor.y + (neighbor.y - checker.y),
                            })
                        end
                    else -- there is no checker there to jump, and it's valid to move there, so move there
                        return checker:move(neighbor.x, neighbor.y)
                    end
                end
            end
        end
    end

    -- if we got here there's nothing to do...
    return self.player:endTurn()
end

-- this is called when the server is no longer taking game commands from you, normally when you turn ends and another players begins.
function AI:ignoring()
    -- pass
end

-- this is called when the game closes (ends), you can clean up your data and dump files here if need be
function AI:close()
    -- pass
end

return AI
